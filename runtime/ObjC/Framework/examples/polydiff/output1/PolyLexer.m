/** \file
 *  This OBJC source file was generated by $ANTLR version 3.3.1-SNAPSHOT Feb 11, 2011 09:03:22
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g
 *     -                            On : 2011-02-11 09:08:07
 *     -                 for the lexer : PolyLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// $ANTLR 3.3.1-SNAPSHOT Feb 11, 2011 09:03:22 /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g 2011-02-11 09:08:07


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "PolyLexer.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */

/** As per Terence: No returns for lexer rules! */
@implementation PolyLexer // line 330

+ (void) initialize
{
    [BaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g"];
}

+ (NSString *) tokenNameForType:(NSInteger)aTokenType
{
    return [[self getTokenNames] objectAtIndex:aTokenType];
}

+ (PolyLexer *)newPolyLexerWithCharStream:(id<CharStream>)anInput
{
    return [[PolyLexer alloc] initWithCharStream:anInput];
}

- (id) initWithCharStream:(id<CharStream>)anInput
{
    if ((self = [super initWithCharStream:anInput State:[RecognizerSharedState newRecognizerSharedStateWithRuleLen:6+1]]) != nil) {

    }
    return self;
}

- (void) dealloc
{
    [super dealloc];
}

/* ObjC Start of actions.lexer.methods */
/* ObjC end of actions.lexer.methods */
/* ObjC start methods() */
/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "T__8"
- (void) mT__8
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__8;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:7:6: ( '+' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:7:8: '+' // alt
        {
        [self matchChar:'+']; 


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
// $ANTLR end "T__8"

// $ANTLR start "T__9"
- (void) mT__9
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = T__9;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:8:6: ( '^' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:8:8: '^' // alt
        {
        [self matchChar:'^']; 


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
// $ANTLR end "T__9"

// $ANTLR start "ID"
- (void) mID
{
    //
    /* ruleScopeSetUp */

    NSString * value = nil;

    @try {
        NSInteger _type = ID;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:22:5: ( ( 'a' .. 'z' )+ ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:22:7: ( 'a' .. 'z' )+ // alt
        {
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:22:7: ( 'a' .. 'z' )+ // positiveClosureBlock
        NSInteger cnt1 = 0;
        do {
            NSInteger alt1 = 2;
            NSInteger LA1_0 = [input LA:1];
            if ( ((LA1_0>='a' && LA1_0<='z')) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:22:7: 'a' .. 'z' // alt
                    {
                    [self matchRangeFromChar:'a' to:'z']; 

                    }
                    break;

                default :
                    if ( cnt1 >= 1 )
                        goto loop1;
                    EarlyExitException *eee = 
                        [EarlyExitException exceptionWithStream:input decisionNumber:1];
                    @throw eee;
            }
            cnt1++;
        } while (YES);
        loop1: ;


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
// $ANTLR end "ID"

// $ANTLR start "INT"
- (void) mINT
{
    //
    /* ruleScopeSetUp */

    NSString * value = nil;

    @try {
        NSInteger _type = INT;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:25:5: ( ( '0' .. '9' )+ ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:25:7: ( '0' .. '9' )+ // alt
        {
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:25:7: ( '0' .. '9' )+ // positiveClosureBlock
        NSInteger cnt2 = 0;
        do {
            NSInteger alt2 = 2;
            NSInteger LA2_0 = [input LA:1];
            if ( ((LA2_0>='0' && LA2_0<='9')) ) {
                alt2=1;
            }


            switch (alt2) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:25:7: '0' .. '9' // alt
                    {
                    [self matchRangeFromChar:'0' to:'9']; 

                    }
                    break;

                default :
                    if ( cnt2 >= 1 )
                        goto loop2;
                    EarlyExitException *eee = 
                        [EarlyExitException exceptionWithStream:input decisionNumber:2];
                    @throw eee;
            }
            cnt2++;
        } while (YES);
        loop2: ;


        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
// $ANTLR end "INT"

// $ANTLR start "WS"
- (void) mWS
{
    //
    /* ruleScopeSetUp */

    @try {
        NSInteger _type = WS;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:27:4: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:27:6: ( ' ' | '\\t' | '\\r' | '\\n' )+ // alt
        {
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:27:6: ( ' ' | '\\t' | '\\r' | '\\n' )+ // positiveClosureBlock
        NSInteger cnt3 = 0;
        do {
            NSInteger alt3 = 2;
            NSInteger LA3_0 = [input LA:1];
            if ( ((LA3_0>='\t' && LA3_0<='\n')||LA3_0=='\r'||LA3_0==' ') ) {
                alt3=1;
            }


            switch (alt3) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g: // alt
                    {
                    if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
                        [input consume];

                    } else {
                        MismatchedSetException *mse = [MismatchedSetException exceptionWithSet:nil stream:input];
                        [self recover:mse];
                        @throw mse;}


                    }
                    break;

                default :
                    if ( cnt3 >= 1 )
                        goto loop3;
                    EarlyExitException *eee = 
                        [EarlyExitException exceptionWithStream:input decisionNumber:3];
                    @throw eee;
            }
            cnt3++;
        } while (YES);
        loop3: ;

         _channel=HIDDEN; 

        }

        // token+rule list labels

        [state setType:_type];

        state.channel = _channel;
    }
    @finally {
        //
    }
    return;
}
// $ANTLR end "WS"

- (void) mTokens
{
    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:1:8: ( T__8 | T__9 | ID | INT | WS ) //ruleblock
    NSInteger alt4=5;
    switch ([input LA:1]) {
        case '+': ;
            {
            alt4=1;
            }
            break;
        case '^': ;
            {
            alt4=2;
            }
            break;
        case 'a': ;
        case 'b': ;
        case 'c': ;
        case 'd': ;
        case 'e': ;
        case 'f': ;
        case 'g': ;
        case 'h': ;
        case 'i': ;
        case 'j': ;
        case 'k': ;
        case 'l': ;
        case 'm': ;
        case 'n': ;
        case 'o': ;
        case 'p': ;
        case 'q': ;
        case 'r': ;
        case 's': ;
        case 't': ;
        case 'u': ;
        case 'v': ;
        case 'w': ;
        case 'x': ;
        case 'y': ;
        case 'z': ;
            {
            alt4=3;
            }
            break;
        case '0': ;
        case '1': ;
        case '2': ;
        case '3': ;
        case '4': ;
        case '5': ;
        case '6': ;
        case '7': ;
        case '8': ;
        case '9': ;
            {
            alt4=4;
            }
            break;
        case '\t': ;
        case '\n': ;
        case '\r': ;
        case ' ': ;
            {
            alt4=5;
            }
            break;

    default: ;
        NoViableAltException *nvae = [NoViableAltException newNoViableAltException:4 state:0 stream:input];
        @throw nvae;
    }

    switch (alt4) {
        case 1 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:1:10: T__8 // alt
            {
            [self mT__8]; 


            }
            break;
        case 2 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:1:15: T__9 // alt
            {
            [self mT__9]; 


            }
            break;
        case 3 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:1:20: ID // alt
            {
            [self mID]; 


            }
            break;
        case 4 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:1:23: INT // alt
            {
            [self mINT]; 


            }
            break;
        case 5 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Poly.g:1:27: WS // alt
            {
            [self mWS]; 


            }
            break;

    }

}

@end /* end of PolyLexer implementation line 397 */