/** \file
 *  This OBJC source file was generated by $ANTLR version 3.3.1-SNAPSHOT Feb 11, 2011 09:03:22
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g
 *     -                            On : 2011-02-11 09:07:52
 *     -           for the tree parser : SimplifierTreeParser *
 * Editing it, at least manually, is not wise. 
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// $ANTLR 3.3.1-SNAPSHOT Feb 11, 2011 09:03:22 /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g 2011-02-11 09:07:52


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "Simplifier.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */
#pragma mark Cyclic DFA implementation start DFA1
@implementation DFA1
const static NSInteger dfa1_eot[10] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa1_eof[10] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa1_min[10] =
    {4,0,0,0,0,0,0,0,0,0};
const static unichar dfa1_max[10] =
    {9,0,0,0,0,0,0,0,0,0};
const static NSInteger dfa1_accept[10] =
    {-1,-1,5,6,7,8,1,2,3,4};
const static NSInteger dfa1_special[10] =
    {-1,0,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa1_transition[] = {};
const static NSInteger dfa1_transition0[] = {2, 4, 5, -1, 1, 3};
const static NSInteger dfa1_transition1[] = {-1};


+ (id) newDFA1WithRecognizer:(BaseRecognizer *)aRecognizer
{
    return [[[DFA1 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(BaseRecognizer *) theRecognizer
{
    if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
        decisionNumber = 1;
        eot = dfa1_eot;
        eof = dfa1_eof;
        min = dfa1_min;
        max = dfa1_max;
        accept = dfa1_accept;
        special = dfa1_special;
        if (!(transition = calloc(10, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 10;
        transition[0] = dfa1_transition0;
        transition[1] = dfa1_transition1;
        transition[2] = dfa1_transition;
        transition[3] = dfa1_transition;
        transition[4] = dfa1_transition;
        transition[5] = dfa1_transition;
        transition[6] = dfa1_transition;
        transition[7] = dfa1_transition;
        transition[8] = dfa1_transition;
        transition[9] = dfa1_transition;
    }
    return self;
}

/* start dfa.specialStateSTs */
- (NSInteger) specialStateTransition:(NSInteger)s Stream:(id<IntStream>)anInput
{
    id<TreeNodeStream> input = (id<TreeNodeStream>)anInput;
    switch (s) {
                case 0 : ;
                    /* cyclicDFAState */
                    NSInteger LA1_1 = [input LA:1];

                     
                    NSInteger index1_1 = [input getIndex];
                    [input rewind];
                    s = -1;
                    /* cyclicDFAEdge */
                    if ([self evaluateSyntacticPredicate:@selector(synpred1_Simplifier_fragment)]) { s = 6;}

                    else /* cyclicDFAEdge */
                    if ([self evaluateSyntacticPredicate:@selector(synpred2_Simplifier_fragment)]) { s = 7;}

                    else /* cyclicDFAEdge */
                    if ([self evaluateSyntacticPredicate:@selector(synpred3_Simplifier_fragment)]) { s = 8;}

                    else /* cyclicDFAEdge */
                    if ([self evaluateSyntacticPredicate:@selector(synpred4_Simplifier_fragment)]) { s = 9;}

                     
                    [input seek:index1_1];
                    if ( s >= 0 )
                        return s;
                     break;
    }
    if ( [recognizer getBacktrackingLevel] > 0 ) { [recognizer setFailed:YES]; return -1; }
    NoViableAltException *nvae = [NoViableAltException newNoViableAltException:1 state:s stream:recognizer.input];
    /* [self error:nvae]; */ 
    @throw nvae;
}

/* end dfa.specialStateSTs */
- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"11:1: poly : ( ^( '+' a= INT b= INT ) -> INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] | ^( '+' ^( '+' a= INT p= poly ) b= INT ) -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] ) | ^( '+' ^( '+' p= poly a= INT ) b= INT ) -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] ) | ^( '+' p= poly q= poly ) -> { [[$p.tree toStringTree] isEqualToString:@\"0\"] }? $q -> { [[$q.tree toStringTree] isEqualToString:@\"0\"] }? $p -> ^( '+' $p $q) | ^( MULT INT poly ) -> {$INT.int==1}? poly -> ^( MULT INT poly ) | ^( '^' ID e= INT ) -> {$e.int==1}? ID -> {$e.int==0}? INT[@\"1\"] -> ^( '^' ID INT ) | INT | ID );";
}


@end /* end DFA1 implementation */

#pragma mark Cyclic DFA implementation end DFA1



#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_8_in_poly52;
static const unsigned long long FOLLOW_8_in_poly52_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_INT_in_poly56;
static const unsigned long long FOLLOW_INT_in_poly56_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_INT_in_poly60;
static const unsigned long long FOLLOW_INT_in_poly60_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_8_in_poly73;
static const unsigned long long FOLLOW_8_in_poly73_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_8_in_poly76;
static const unsigned long long FOLLOW_8_in_poly76_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_INT_in_poly80;
static const unsigned long long FOLLOW_INT_in_poly80_data[] = { 0x0000000000000370LL};
static ANTLRBitSet *FOLLOW_poly_in_poly84;
static const unsigned long long FOLLOW_poly_in_poly84_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_INT_in_poly89;
static const unsigned long long FOLLOW_INT_in_poly89_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_8_in_poly117;
static const unsigned long long FOLLOW_8_in_poly117_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_8_in_poly120;
static const unsigned long long FOLLOW_8_in_poly120_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_poly_in_poly124;
static const unsigned long long FOLLOW_poly_in_poly124_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_INT_in_poly128;
static const unsigned long long FOLLOW_INT_in_poly128_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_INT_in_poly133;
static const unsigned long long FOLLOW_INT_in_poly133_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_8_in_poly161;
static const unsigned long long FOLLOW_8_in_poly161_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_poly_in_poly165;
static const unsigned long long FOLLOW_poly_in_poly165_data[] = { 0x0000000000000370LL};
static ANTLRBitSet *FOLLOW_poly_in_poly169;
static const unsigned long long FOLLOW_poly_in_poly169_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_MULT_in_poly216;
static const unsigned long long FOLLOW_MULT_in_poly216_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_INT_in_poly218;
static const unsigned long long FOLLOW_INT_in_poly218_data[] = { 0x0000000000000370LL};
static ANTLRBitSet *FOLLOW_poly_in_poly220;
static const unsigned long long FOLLOW_poly_in_poly220_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_9_in_poly251;
static const unsigned long long FOLLOW_9_in_poly251_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_ID_in_poly253;
static const unsigned long long FOLLOW_ID_in_poly253_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_INT_in_poly257;
static const unsigned long long FOLLOW_INT_in_poly257_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_INT_in_poly302;
static const unsigned long long FOLLOW_INT_in_poly302_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_poly307;
static const unsigned long long FOLLOW_ID_in_poly307_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_8_in_synpred1_Simplifier52;
static const unsigned long long FOLLOW_8_in_synpred1_Simplifier52_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_INT_in_synpred1_Simplifier56;
static const unsigned long long FOLLOW_INT_in_synpred1_Simplifier56_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_INT_in_synpred1_Simplifier60;
static const unsigned long long FOLLOW_INT_in_synpred1_Simplifier60_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_8_in_synpred2_Simplifier73;
static const unsigned long long FOLLOW_8_in_synpred2_Simplifier73_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_8_in_synpred2_Simplifier76;
static const unsigned long long FOLLOW_8_in_synpred2_Simplifier76_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_INT_in_synpred2_Simplifier80;
static const unsigned long long FOLLOW_INT_in_synpred2_Simplifier80_data[] = { 0x0000000000000370LL};
static ANTLRBitSet *FOLLOW_poly_in_synpred2_Simplifier84;
static const unsigned long long FOLLOW_poly_in_synpred2_Simplifier84_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_INT_in_synpred2_Simplifier89;
static const unsigned long long FOLLOW_INT_in_synpred2_Simplifier89_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_8_in_synpred3_Simplifier117;
static const unsigned long long FOLLOW_8_in_synpred3_Simplifier117_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_8_in_synpred3_Simplifier120;
static const unsigned long long FOLLOW_8_in_synpred3_Simplifier120_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_poly_in_synpred3_Simplifier124;
static const unsigned long long FOLLOW_poly_in_synpred3_Simplifier124_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_INT_in_synpred3_Simplifier128;
static const unsigned long long FOLLOW_INT_in_synpred3_Simplifier128_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_INT_in_synpred3_Simplifier133;
static const unsigned long long FOLLOW_INT_in_synpred3_Simplifier133_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_8_in_synpred4_Simplifier161;
static const unsigned long long FOLLOW_8_in_synpred4_Simplifier161_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_poly_in_synpred4_Simplifier165;
static const unsigned long long FOLLOW_poly_in_synpred4_Simplifier165_data[] = { 0x0000000000000370LL};
static ANTLRBitSet *FOLLOW_poly_in_synpred4_Simplifier169;
static const unsigned long long FOLLOW_poly_in_synpred4_Simplifier169_data[] = { 0x0000000000000008LL};


#pragma mark Dynamic Global Scopes

#pragma mark Dynamic Rule Scopes

#pragma mark Rule return scopes start
@implementation Simplifier_poly_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (Simplifier_poly_return *)newSimplifier_poly_return
{
    return [[[Simplifier_poly_return alloc] init] retain];
}

/* ASTTreeParser returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */

@implementation Simplifier_synpred1_Simplifier_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (Simplifier_synpred1_Simplifier_return *)newSimplifier_synpred1_Simplifier_return
{
    return [[[Simplifier_synpred1_Simplifier_return alloc] init] retain];
}

/* ASTTreeParser returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */

@implementation Simplifier_synpred2_Simplifier_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (Simplifier_synpred2_Simplifier_return *)newSimplifier_synpred2_Simplifier_return
{
    return [[[Simplifier_synpred2_Simplifier_return alloc] init] retain];
}

/* ASTTreeParser returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */

@implementation Simplifier_synpred3_Simplifier_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (Simplifier_synpred3_Simplifier_return *)newSimplifier_synpred3_Simplifier_return
{
    return [[[Simplifier_synpred3_Simplifier_return alloc] init] retain];
}

/* ASTTreeParser returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */

@implementation Simplifier_synpred4_Simplifier_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (Simplifier_synpred4_Simplifier_return *)newSimplifier_synpred4_Simplifier_return
{
    return [[[Simplifier_synpred4_Simplifier_return alloc] init] retain];
}

/* ASTTreeParser returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if (tree != nil) [tree release];
        if (aTree != nil) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    [self setTree:nil];
    [super dealloc];
}




@end /* end of returnScope implementation */



#pragma mark Rule attributes scope methods

@implementation Simplifier  // line 637

+ (void) initialize
{
    #pragma mark Bitsets
    FOLLOW_8_in_poly52 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_poly52_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly56 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly56_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly60 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly60_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_poly73 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_poly73_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_poly76 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_poly76_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly80 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly80_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_poly84 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_poly84_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly89 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly89_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_poly117 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_poly117_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_poly120 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_poly120_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_poly124 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_poly124_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly128 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly128_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly133 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly133_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_poly161 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_poly161_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_poly165 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_poly165_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_poly169 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_poly169_data Count:(NSUInteger)1] retain];
    FOLLOW_MULT_in_poly216 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_MULT_in_poly216_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly218 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly218_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_poly220 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_poly220_data Count:(NSUInteger)1] retain];
    FOLLOW_9_in_poly251 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_9_in_poly251_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_poly253 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_poly253_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly257 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly257_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_poly302 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_poly302_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_poly307 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_poly307_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_synpred1_Simplifier52 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_synpred1_Simplifier52_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_synpred1_Simplifier56 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_synpred1_Simplifier56_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_synpred1_Simplifier60 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_synpred1_Simplifier60_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_synpred2_Simplifier73 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_synpred2_Simplifier73_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_synpred2_Simplifier76 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_synpred2_Simplifier76_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_synpred2_Simplifier80 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_synpred2_Simplifier80_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_synpred2_Simplifier84 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_synpred2_Simplifier84_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_synpred2_Simplifier89 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_synpred2_Simplifier89_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_synpred3_Simplifier117 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_synpred3_Simplifier117_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_synpred3_Simplifier120 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_synpred3_Simplifier120_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_synpred3_Simplifier124 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_synpred3_Simplifier124_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_synpred3_Simplifier128 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_synpred3_Simplifier128_data Count:(NSUInteger)1] retain];
    FOLLOW_INT_in_synpred3_Simplifier133 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_synpred3_Simplifier133_data Count:(NSUInteger)1] retain];
    FOLLOW_8_in_synpred4_Simplifier161 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_8_in_synpred4_Simplifier161_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_synpred4_Simplifier165 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_synpred4_Simplifier165_data Count:(NSUInteger)1] retain];
    FOLLOW_poly_in_synpred4_Simplifier169 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_poly_in_synpred4_Simplifier169_data Count:(NSUInteger)1] retain];

    [BaseRecognizer setTokenNames:[[NSArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"MULT", @"INT", @"ID", @"WS", @"'+'", @"'^'", nil] retain]];
    [BaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g"];
    SEL synpred2_SimplifierSelector = @selector(synpred2_Simplifier_fragment);
    SEL synpred1_SimplifierSelector = @selector(synpred1_Simplifier_fragment);
    SEL synpred4_SimplifierSelector = @selector(synpred4_Simplifier_fragment);
    SEL synpred3_SimplifierSelector = @selector(synpred3_Simplifier_fragment);

}

+ (Simplifier *)newSimplifier:(id<TreeNodeStream>)aStream
{

    return [[Simplifier alloc] initWithStream:aStream];

}


- (id) initWithStream:(id<TreeNodeStream>)aStream
{
    if ((self = [super initWithStream:aStream State:[[RecognizerSharedState newRecognizerSharedStateWithRuleLen:8+1] retain]]) != nil) {


        dfa1 = [DFA1 newDFA1WithRecognizer:self];
        /* start of actions-actionScope-init */
        /* start of init */
        /* AST genericParser.init */
        [self setTreeAdaptor:[[CommonTreeAdaptor newTreeAdaptor] retain]];
    }
    return self;
}

- (void) dealloc
{
    [dfa1 release];
    /* AST genericParser.dealloc */
    [self setTreeAdaptor:nil];

    [super dealloc];
}

/* ObjC start members */
/* ObjC end members */
/* ObjC start actions.(actionScope).methods */
/* ObjC end actions.(actionScope).methods */
/* ObjC start methods() */
/* AST genericParser.methods */
/* AST parserMethods */
- (id<TreeAdaptor>) getTreeAdaptor
{
	return treeAdaptor;
}

- (void) setTreeAdaptor:(id<TreeAdaptor>)aTreeAdaptor
{
	if (aTreeAdaptor != treeAdaptor) {
		treeAdaptor = aTreeAdaptor;
	}
}
/* ObjC end methods() */
/* ObjC start rules */
/*
 * $ANTLR start poly
 * /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:11:1: poly : ( ^( '+' a= INT b= INT ) -> INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] | ^( '+' ^( '+' a= INT p= poly ) b= INT ) -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] ) | ^( '+' ^( '+' p= poly a= INT ) b= INT ) -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] ) | ^( '+' p= poly q= poly ) -> { [[$p.tree toStringTree] isEqualToString:@\"0\"] }? $q -> { [[$q.tree toStringTree] isEqualToString:@\"0\"] }? $p -> ^( '+' $p $q) | ^( MULT INT poly ) -> {$INT.int==1}? poly -> ^( MULT INT poly ) | ^( '^' ID e= INT ) -> {$e.int==1}? ID -> {$e.int==0}? INT[@\"1\"] -> ^( '^' ID INT ) | INT | ID );
 */
- (Simplifier_poly_return *) poly
{
    /* ruleScopeSetUp */

    /* ASTTreeParser ruleDeclarations */
    /* AST ruleDeclarations */
    Simplifier_poly_return * retval = [Simplifier_poly_return newSimplifier_poly_return];
    [retval setStart:[input LT:1]];

    CommonTree *root_0 = nil;

    CommonTree *_first_0 = nil;
    CommonTree *_last = nil;

    @try {
        /* AST ruleLabelDefs */
        CommonTree *a = nil;
        CommonTree *b = nil;
        CommonTree *e = nil;
        CommonTree *char_literal1 = nil;
        CommonTree *char_literal2 = nil;
        CommonTree *char_literal3 = nil;
        CommonTree *char_literal4 = nil;
        CommonTree *char_literal5 = nil;
        CommonTree *char_literal6 = nil;
        CommonTree *MULT7 = nil;
        CommonTree *INT8 = nil;
        CommonTree *char_literal10 = nil;
        CommonTree *ID11 = nil;
        CommonTree *INT12 = nil;
        CommonTree *ID13 = nil;
        Simplifier_poly_return * p = nil;

        Simplifier_poly_return * q = nil;

        Simplifier_poly_return * poly9 = nil;


        CommonTree *a_tree=nil;
        CommonTree *b_tree=nil;
        CommonTree *e_tree=nil;
        CommonTree *char_literal1_tree=nil;
        CommonTree *char_literal2_tree=nil;
        CommonTree *char_literal3_tree=nil;
        CommonTree *char_literal4_tree=nil;
        CommonTree *char_literal5_tree=nil;
        CommonTree *char_literal6_tree=nil;
        CommonTree *MULT7_tree=nil;
        CommonTree *INT8_tree=nil;
        CommonTree *char_literal10_tree=nil;
        CommonTree *ID11_tree=nil;
        CommonTree *INT12_tree=nil;
        CommonTree *ID13_tree=nil;
        RewriteRuleTokenStream *stream_INT = 
            [[RewriteRuleNodeStream newRewriteRuleNodeStream:treeAdaptor
                                                             description:@"token INT"] retain];
        RewriteRuleTokenStream *stream_MULT = 
            [[RewriteRuleNodeStream newRewriteRuleNodeStream:treeAdaptor
                                                             description:@"token MULT"] retain];
        RewriteRuleTokenStream *stream_ID = 
            [[RewriteRuleNodeStream newRewriteRuleNodeStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleTokenStream *stream_9 = 
            [[RewriteRuleNodeStream newRewriteRuleNodeStream:treeAdaptor
                                                             description:@"token 9"] retain];
        RewriteRuleTokenStream *stream_8 = 
            [[RewriteRuleNodeStream newRewriteRuleNodeStream:treeAdaptor
                                                             description:@"token 8"] retain];
        RewriteRuleSubtreeStream *stream_poly = 
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule poly"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:16:5: ( ^( '+' a= INT b= INT ) -> INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] | ^( '+' ^( '+' a= INT p= poly ) b= INT ) -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] ) | ^( '+' ^( '+' p= poly a= INT ) b= INT ) -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] ) | ^( '+' p= poly q= poly ) -> { [[$p.tree toStringTree] isEqualToString:@\"0\"] }? $q -> { [[$q.tree toStringTree] isEqualToString:@\"0\"] }? $p -> ^( '+' $p $q) | ^( MULT INT poly ) -> {$INT.int==1}? poly -> ^( MULT INT poly ) | ^( '^' ID e= INT ) -> {$e.int==1}? ID -> {$e.int==0}? INT[@\"1\"] -> ^( '^' ID INT ) | INT | ID ) //ruleblock
        NSInteger alt1=8;
        alt1 = [dfa1 predict:input];
        switch (alt1) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:16:7: ^( '+' a= INT b= INT ) // alt
                {
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_1 = _last;
                CommonTree *_first_1 = nil;
                CommonTree *root_1 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                char_literal1=(CommonTree *)[self match:input TokenType:8 Follow:FOLLOW_8_in_poly52]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_8 addElement:char_literal1];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                a=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly56]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:a];

                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                b=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly60]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:b];


                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_1 toTree:root_0];_last = _save_last_1;
                }



                // AST REWRITE
                // elements: INT
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( state.backtracking == 0 ) {
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 16:26: -> INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]]
                {
                    [treeAdaptor addChild:[treeAdaptor createTree:INT FromToken:[NSString stringWithFormat:@"%d", ((a!=nil?[a.text integerValue]:0)+(b!=nil?[b.text integerValue]:0))] Text:@"INT"] toTree:root_0];

                }

                retval.tree = root_0;
                }
                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:18:4: ^( '+' ^( '+' a= INT p= poly ) b= INT ) // alt
                {
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_1 = _last;
                CommonTree *_first_1 = nil;
                CommonTree *root_1 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                char_literal2=(CommonTree *)[self match:input TokenType:8 Follow:FOLLOW_8_in_poly73]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_8 addElement:char_literal2];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_2 = _last;
                CommonTree *_first_2 = nil;
                CommonTree *root_2 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                char_literal3=(CommonTree *)[self match:input TokenType:8 Follow:FOLLOW_8_in_poly76]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_8 addElement:char_literal3];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                a=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly80]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:a];

                /* ASTTreeParser ruleRefTrack */
                _last = (CommonTree *)[input LT:1];
                /* ruleRef */
                [self pushFollow:FOLLOW_poly_in_poly84];
                p = [self poly];

                [self popFollow];
                if ( state.failed ) return retval;

                if ( state.backtracking == 0 ) 
                [stream_poly addElement:[p getTree]];

                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_2 toTree:root_1];_last = _save_last_2;
                }

                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                b=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly89]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:b];


                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_1 toTree:root_0];_last = _save_last_1;
                }



                // AST REWRITE
                // elements: INT, 8, p
                // token labels: 
                // rule labels: retval, p
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( state.backtracking == 0 ) {
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
                RewriteRuleSubtreeStream *stream_p =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token p" element:p!=nil?[p getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 19:8: -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:19:11: ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_8 nextNode] old:root_1];

                        [treeAdaptor addChild:[stream_p nextTree] toTree:root_1];
                        [treeAdaptor addChild:[treeAdaptor createTree:INT FromToken:[NSString stringWithFormat:@"%d", ((a!=nil?[a.text integerValue]:0)+(b!=nil?[b.text integerValue]:0))] Text:@"INT"] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;
                }
                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:21:4: ^( '+' ^( '+' p= poly a= INT ) b= INT ) // alt
                {
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_1 = _last;
                CommonTree *_first_1 = nil;
                CommonTree *root_1 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                char_literal4=(CommonTree *)[self match:input TokenType:8 Follow:FOLLOW_8_in_poly117]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_8 addElement:char_literal4];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_2 = _last;
                CommonTree *_first_2 = nil;
                CommonTree *root_2 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                char_literal5=(CommonTree *)[self match:input TokenType:8 Follow:FOLLOW_8_in_poly120]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_8 addElement:char_literal5];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser ruleRefTrack */
                _last = (CommonTree *)[input LT:1];
                /* ruleRef */
                [self pushFollow:FOLLOW_poly_in_poly124];
                p = [self poly];

                [self popFollow];
                if ( state.failed ) return retval;

                if ( state.backtracking == 0 ) 
                [stream_poly addElement:[p getTree]];
                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                a=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly128]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:a];


                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_2 toTree:root_1];_last = _save_last_2;
                }

                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                b=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly133]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:b];


                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_1 toTree:root_0];_last = _save_last_1;
                }



                // AST REWRITE
                // elements: p, INT, 8
                // token labels: 
                // rule labels: retval, p
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( state.backtracking == 0 ) {
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
                RewriteRuleSubtreeStream *stream_p =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token p" element:p!=nil?[p getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 22:8: -> ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:22:11: ^( '+' $p INT[[NSString stringWithFormat:@\"\\%d\", ($a.int+$b.int)]] )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_8 nextNode] old:root_1];

                        [treeAdaptor addChild:[stream_p nextTree] toTree:root_1];
                        [treeAdaptor addChild:[treeAdaptor createTree:INT FromToken:[NSString stringWithFormat:@"%d", ((a!=nil?[a.text integerValue]:0)+(b!=nil?[b.text integerValue]:0))] Text:@"INT"] toTree:root_1];
                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;
                }
                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:24:4: ^( '+' p= poly q= poly ) // alt
                {
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_1 = _last;
                CommonTree *_first_1 = nil;
                CommonTree *root_1 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                char_literal6=(CommonTree *)[self match:input TokenType:8 Follow:FOLLOW_8_in_poly161]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_8 addElement:char_literal6];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser ruleRefTrack */
                _last = (CommonTree *)[input LT:1];
                /* ruleRef */
                [self pushFollow:FOLLOW_poly_in_poly165];
                p = [self poly];

                [self popFollow];
                if ( state.failed ) return retval;

                if ( state.backtracking == 0 ) 
                [stream_poly addElement:[p getTree]];
                /* ASTTreeParser ruleRefTrack */
                _last = (CommonTree *)[input LT:1];
                /* ruleRef */
                [self pushFollow:FOLLOW_poly_in_poly169];
                q = [self poly];

                [self popFollow];
                if ( state.failed ) return retval;

                if ( state.backtracking == 0 ) 
                [stream_poly addElement:[q getTree]];

                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_1 toTree:root_0];_last = _save_last_1;
                }



                // AST REWRITE
                // elements: q, 8, q, p, p
                // token labels: 
                // rule labels: retval, q, p
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( state.backtracking == 0 ) {
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
                RewriteRuleSubtreeStream *stream_q =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token q" element:q!=nil?[q getTree]:nil] retain];
                RewriteRuleSubtreeStream *stream_p =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token p" element:p!=nil?[p getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 24:24: -> { [[$p.tree toStringTree] isEqualToString:@\"0\"] }? $q
                if ( [[(p!=nil?((CommonTree *)p.tree):nil) toStringTree] isEqualToString:@"0"] ) {
                    [treeAdaptor addChild:[stream_q nextTree] toTree:root_0];

                }
                else // 25:8: -> { [[$q.tree toStringTree] isEqualToString:@\"0\"] }? $p
                if ( [[(q!=nil?((CommonTree *)q.tree):nil) toStringTree] isEqualToString:@"0"] ) {
                    [treeAdaptor addChild:[stream_p nextTree] toTree:root_0];

                }
                else // 26:8: -> ^( '+' $p $q)
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:26:11: ^( '+' $p $q)
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_8 nextNode] old:root_1];

                        [treeAdaptor addChild:[stream_p nextTree] toTree:root_1];
                        [treeAdaptor addChild:[stream_q nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;
                }
                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:28:4: ^( MULT INT poly ) // alt
                {
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_1 = _last;
                CommonTree *_first_1 = nil;
                CommonTree *root_1 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                MULT7=(CommonTree *)[self match:input TokenType:MULT Follow:FOLLOW_MULT_in_poly216]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_MULT addElement:MULT7];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                INT8=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly218]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:INT8];

                /* ASTTreeParser ruleRefTrack */
                _last = (CommonTree *)[input LT:1];
                /* ruleRef */
                [self pushFollow:FOLLOW_poly_in_poly220];
                poly9 = [self poly];

                [self popFollow];
                if ( state.failed ) return retval;

                if ( state.backtracking == 0 ) 
                [stream_poly addElement:[poly9 getTree]];

                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_1 toTree:root_0];_last = _save_last_1;
                }



                // AST REWRITE
                // elements: poly, INT, poly, MULT
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( state.backtracking == 0 ) {
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 28:21: -> {$INT.int==1}? poly
                if ( (INT8!=nil?[INT8.text integerValue]:0)==1 ) {
                    [treeAdaptor addChild:[stream_poly nextTree] toTree:root_0];

                }
                else // 29:8: -> ^( MULT INT poly )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:29:11: ^( MULT INT poly )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_MULT nextNode] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_INT nextNode] toTree:root_1];
                        [treeAdaptor addChild:[stream_poly nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;
                }
                }
                break;
            case 6 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:31:4: ^( '^' ID e= INT ) // alt
                {
                /* ASTTreeParser tree */
                _last = (CommonTree *)[input LT:1];
                {
                CommonTree *_save_last_1 = _last;
                CommonTree *_first_1 = nil;
                CommonTree *root_1 = [[[treeAdaptor class] newEmptyTree] retain];/* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                char_literal10=(CommonTree *)[self match:input TokenType:9 Follow:FOLLOW_9_in_poly251]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_9 addElement:char_literal10];



                [self match:input TokenType:TokenTypeDOWN Follow:nil]; if ( state.failed ) return retval;
                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                ID11=(CommonTree *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_poly253]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_ID addElement:ID11];

                /* ASTTreeParser tokenRefBang */
                _last = (CommonTree *)[input LT:1];
                e=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly257]; if ( state.failed ) return retval; 
                if ( state.backtracking == 0 ) 
                    [stream_INT addElement:e];


                [self match:input TokenType:TokenTypeUP Follow:nil]; if ( state.failed ) return retval;[treeAdaptor addChild:root_1 toTree:root_0];_last = _save_last_1;
                }



                // AST REWRITE
                // elements: INT, ID, ID, INT, 9
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                if ( state.backtracking == 0 ) {
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 31:21: -> {$e.int==1}? ID
                if ((e!=nil?[e.text integerValue]:0)==1) {
                     // TODO: args: 
                    [treeAdaptor addChild:/* ASTTreeParser createRewriteNodeFromElement */
                    [stream_ID nextNode] toTree:root_0];

                }
                else // 32:8: -> {$e.int==0}? INT[@\"1\"]
                if ((e!=nil?[e.text] integerValue]:0)==0) {
                    [treeAdaptor addChild:        [treeAdaptor createTree:INT FromToken:@"1" Text:@"INT"] toTree:root_0];

                }
                else // 33:8: -> ^( '^' ID INT )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:33:11: ^( '^' ID INT )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_9 nextNode] old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_ID nextNode] toTree:root_1];
                         // TODO: args: 
                        [treeAdaptor addChild:/* ASTTreeParser createRewriteNodeFromElement */
                        [stream_INT nextNode] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                retval.tree = root_0;
                }
                }
                break;
            case 7 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:35:4: INT // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTTreeParser tokenRef */
                _last = (CommonTree *)[input LT:1];
                INT12=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_poly302]; if ( state.failed ) return retval;
                if ( state.backtracking == 0 ) {
                    INT12_tree = (CommonTree *)[treeAdaptor dupNode:INT12];

                    [treeAdaptor addChild:INT12_tree toTree:root_0];
                }

                /* ASTTreeParser noRewrite */
                if ( state.backtracking == 0 ) {
                }
                }
                break;
            case 8 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:36:4: ID // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                /* ASTTreeParser tokenRef */
                _last = (CommonTree *)[input LT:1];
                ID13=(CommonTree *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_poly307]; if ( state.failed ) return retval;
                if ( state.backtracking == 0 ) {
                    ID13_tree = (CommonTree *)[treeAdaptor dupNode:ID13];

                    [treeAdaptor addChild:ID13_tree toTree:root_0];
                }

                /* ASTTreeParser noRewrite */
                if ( state.backtracking == 0 ) {
                }
                }
                break;

        }
        /* ASTTreeParser ruleCleanUp */
        /* AST ruleCleanUp */
        // token+rule list labels

        [stream_INT release];
        [stream_MULT release];
        [stream_ID release];
        [stream_9 release];
        [stream_8 release];
        [stream_poly release];

        if ( state.backtracking == 0 ) {

        retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
        }
    }
    @catch (RecognitionException *re) {
        [self reportError:re];
        [self recover:input Exception:re];
    }
    @finally {
    }
    return retval;
}
/* $ANTLR end poly */
// $ANTLR start synpred1_Simplifier_fragment
- (void) synpred1_Simplifier_fragment
{
    CommonTree *a = nil;
    CommonTree *b = nil;

    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:16:7: ( ^( '+' a= INT b= INT ) ) // ruleBlockSingleAlt
    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:16:7: ^( '+' a= INT b= INT ) // alt
    {
    [self match:input TokenType:8 Follow:FOLLOW_8_in_synpred1_Simplifier52]; if ( state.failed ) return ;

        [self match:input TokenType:DOWN Follow:nil]; if ( state.failed ) return ;
        a=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_synpred1_Simplifier56]; if ( state.failed ) return ;
        b=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_synpred1_Simplifier60]; if ( state.failed ) return ;

        [self match:input TokenType:UP Follow:nil]; if ( state.failed ) return ;

    }
} // $ANTLR end synpred1_Simplifier_fragment
// $ANTLR start synpred2_Simplifier_fragment
- (void) synpred2_Simplifier_fragment
{
    CommonTree *a = nil;
    CommonTree *b = nil;
    Simplifier_poly_return * p = nil;


    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:18:4: ( ^( '+' ^( '+' a= INT p= poly ) b= INT ) ) // ruleBlockSingleAlt
    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:18:4: ^( '+' ^( '+' a= INT p= poly ) b= INT ) // alt
    {
    [self match:input TokenType:8 Follow:FOLLOW_8_in_synpred2_Simplifier73]; if ( state.failed ) return ;

        [self match:input TokenType:DOWN Follow:nil]; if ( state.failed ) return ;
        [self match:input TokenType:8 Follow:FOLLOW_8_in_synpred2_Simplifier76]; if ( state.failed ) return ;

            [self match:input TokenType:DOWN Follow:nil]; if ( state.failed ) return ;
            a=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_synpred2_Simplifier80]; if ( state.failed ) return ;
            /* ruleRef */
            [self pushFollow:FOLLOW_poly_in_synpred2_Simplifier84];
            p = [self poly];

            [self popFollow];
            if ( state.failed ) return ;


            [self match:input TokenType:UP Follow:nil]; if ( state.failed ) return ;
        b=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_synpred2_Simplifier89]; if ( state.failed ) return ;

        [self match:input TokenType:UP Follow:nil]; if ( state.failed ) return ;

    }
} // $ANTLR end synpred2_Simplifier_fragment
// $ANTLR start synpred3_Simplifier_fragment
- (void) synpred3_Simplifier_fragment
{
    CommonTree *a = nil;
    CommonTree *b = nil;
    Simplifier_poly_return * p = nil;


    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:21:4: ( ^( '+' ^( '+' p= poly a= INT ) b= INT ) ) // ruleBlockSingleAlt
    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:21:4: ^( '+' ^( '+' p= poly a= INT ) b= INT ) // alt
    {
    [self match:input TokenType:8 Follow:FOLLOW_8_in_synpred3_Simplifier117]; if ( state.failed ) return ;

        [self match:input TokenType:DOWN Follow:nil]; if ( state.failed ) return ;
        [self match:input TokenType:8 Follow:FOLLOW_8_in_synpred3_Simplifier120]; if ( state.failed ) return ;

            [self match:input TokenType:DOWN Follow:nil]; if ( state.failed ) return ;
            /* ruleRef */
            [self pushFollow:FOLLOW_poly_in_synpred3_Simplifier124];
            p = [self poly];

            [self popFollow];
            if ( state.failed ) return ;

            a=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_synpred3_Simplifier128]; if ( state.failed ) return ;

            [self match:input TokenType:UP Follow:nil]; if ( state.failed ) return ;
        b=(CommonTree *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_synpred3_Simplifier133]; if ( state.failed ) return ;

        [self match:input TokenType:UP Follow:nil]; if ( state.failed ) return ;

    }
} // $ANTLR end synpred3_Simplifier_fragment
// $ANTLR start synpred4_Simplifier_fragment
- (void) synpred4_Simplifier_fragment
{
    Simplifier_poly_return * p = nil;

    Simplifier_poly_return * q = nil;


    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:24:4: ( ^( '+' p= poly q= poly ) ) // ruleBlockSingleAlt
    // /Users/acondit/source/antlr3/acondit_localhost/code/antlr/main/runtime/ObjC/Framework/examples/polydiff/Simplifier.g:24:4: ^( '+' p= poly q= poly ) // alt
    {
    [self match:input TokenType:8 Follow:FOLLOW_8_in_synpred4_Simplifier161]; if ( state.failed ) return ;

        [self match:input TokenType:DOWN Follow:nil]; if ( state.failed ) return ;
        /* ruleRef */
        [self pushFollow:FOLLOW_poly_in_synpred4_Simplifier165];
        p = [self poly];

        [self popFollow];
        if ( state.failed ) return ;

        /* ruleRef */
        [self pushFollow:FOLLOW_poly_in_synpred4_Simplifier169];
        q = [self poly];

        [self popFollow];
        if ( state.failed ) return ;


        [self match:input TokenType:UP Follow:nil]; if ( state.failed ) return ;

    }
} // $ANTLR end synpred4_Simplifier_fragment
/* ObjC end rules */

@end /* end of Simplifier implementation line 692 */
